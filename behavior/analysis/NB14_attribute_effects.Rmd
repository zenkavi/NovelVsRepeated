---
title: "Novel vs. repeated choice project: Attribute and reference amount effects on choice"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: 'hide'
---

Set up environment and load in data

```{r include=FALSE, message=FALSE}
library(tidyverse)
library(brms)
library(here)
library(lemon)
theme_set(theme_bw())
helpers_path = paste0(here(),'/analysis/helpers/')
inputs_path = paste0(here(),'/inputs/')
source(paste0(helpers_path, '01_clean_behavioral_data.R'))
rm(data_bc_clean)
fig_out_path = paste0(here(), '/outputs/fig/')
```

Add columns that will be used for plots below.

```{r}
data_yn_clean = data_yn_clean %>%
  mutate(correct = ifelse(possiblePayoff>reference & yesChosen == 1, 1, ifelse(possiblePayoff < reference & yesChosen == 0, 1, 0))) %>%
  mutate(type_chr = ifelse(type == 1, "HT", "RE"),
         week = ifelse(week == 1, "Week 1", ifelse(week == 2, "Week 2", ifelse(week == 3, "Week 3", NA))),
         week = factor(week, levels = c("Week 1", "Week 2", "Week 3"))) %>%
  mutate(val_diff = possiblePayoff - reference,
         abs_val_diff = abs(possiblePayoff - reference),
         val_diff_bin = round(val_diff/50),
         val_diff_bin_str = paste0(val_diff_bin*50-25,":",val_diff_bin*50+25),
         val_diff_bin_str = factor(val_diff_bin_str, levels = c("-225:-175", "-175:-125", "-125:-75", "-75:-25", "-25:25", "25:75", "75:125", "125:175", "175:225")))
```

## Attribute effects on accuracy

```{r}
names(data_yn_clean)
```

```{r}
fn_draws = paste0(inputs_path, 'yn_attrVal_cor_draws.csv')

if(file.exists(fn_draws)){
  yn_attr_cor_draws = read.csv(fn_draws)
} else{
  subnums = unique(data_yn_clean$subnum)
 
  yn_attr_cor_draws = tibble()
  
  for(cur_sub in subnums){
  
    cur_dat = data_yn_clean %>% 
      ungroup() %>%
      filter(subnum == cur_sub)
    
    cur_m <- brm(formula = correct ~  valueO * valueF * valueS,
                        data= cur_dat,
                        family = bernoulli(link = "logit"),
                        warmup = 500,
                        iter = 2500,
                        chains = 4,
                        init = "0",
                        cores = 4,
                        seed = 389253)
    
    cur_draws = as_draws_df(cur_m)
    cur_draws$subnum = cur_sub
    
    yn_attr_cor_draws = rbind(yn_attr_cor_draws, cur_draws)
  }
  names(yn_attr_cor_draws) = gsub(":", ".", names(yn_attr_cor_draws))
  write.csv(yn_attr_cor_draws, fn_draws, row.names = F)

  rm(cur_dat, cur_m, cur_draws, cur_sub)
}
rm(subnums)
```


```{r}
names(as_tibble(yn_attr_cor_draws))[grepl("b_", names(as_tibble(yn_attr_cor_draws)))]
```

```{r}
yn_par_summary = as_tibble(yn_attr_cor_draws) %>%
  select(subnum, b_Intercept, b_valueO, b_valueF, b_valueS, b_valueO.valueF, b_valueO.valueS, b_valueF.valueS, b_valueO.valueF.valueS) %>%
  gather(key, value, -subnum) %>%
  mutate(key = recode(key,
                      "b_Intercept" = "Intercept",
                      "b_valueO" = "Orientation Value [-1, 1]", 
                      "b_valueF" = "Filling Value [-1, 1]", 
                      "b_valueS" = "Shape Value [-1, 1]", 
                      "b_valueO.valueF" = "Value O x F", 
                      "b_valueO.valueS" = "Value O x S", 
                      "b_valueF.valueS" = "Value F x S", 
                      "b_valueO.valueF.valueS" = "Value O x F x S"),
         key = factor(key, levels = c("Intercept", "Orientation Value [-1, 1]", "Filling Value [-1, 1]", "Shape Value [-1, 1]", "Value O x F", "Value O x S", "Value F x S", "Value O x F x S"))) %>%
  group_by(subnum, key) %>%
  summarise(.groups = 'keep',
            m = mean(value),
            l95 = HDInterval::hdi(value)[1],
            h95 = HDInterval::hdi(value)[2]) %>%
  mutate(subnum = as.factor(subnum))
```

```{r}
p = yn_par_summary %>%
  ggplot(aes(m, subnum)) +
  geom_vline(aes(xintercept = 0), color = "gray") + 
  geom_point(position = position_dodge(width=.75))+
  geom_errorbarh(aes(xmin = l95, xmax = h95, height=.2), position = position_dodge(width=.75))+
  facet_wrap(~key, scales = 'free_x', nrow = 2) +
  labs(x = "Parameter Estimate", y = "Subject", color = "", title = "95% HDI for posterior slopes - Correct ~ Orientation x Filling x Shape") +
  theme(legend.position = "bottom",
        panel.grid = element_blank(),
        legend.box.margin=margin(t = -10))+
  scale_x_symmetric(mid=0)

# ggsave(file=paste0(fig_out_path, 'yn_attrEffects_ParEsts.jpg'), p, height = 5, width = 9.5, units="in")

p
```

No main effect, no 3-way interaction but all 2-way interactions are significant.

How to interpret the 2-way interactions?  
It means that when the two attribute values aggree accuracy is higher. When they disaggree accuracy is lower.

Does this change by stim type?  
No.

```{r}
fn_draws = paste0(inputs_path, 'yn_attrValByType_cor_draws.csv')

if(file.exists(fn_draws)){
  yn_attr_cor_draws = read.csv(fn_draws)
} else{
  subnums = unique(data_yn_clean$subnum)
 
  yn_attr_cor_draws = tibble()
  
  for(cur_sub in subnums){
  
    cur_dat = data_yn_clean %>% 
      ungroup() %>%
      filter(subnum == cur_sub) %>%
      mutate(type = as.factor(type))
    
    cur_m <- brm(formula = correct ~  valueO * valueF * valueS * type,
                        data= cur_dat,
                        family = bernoulli(link = "logit"),
                        warmup = 500,
                        iter = 2500,
                        chains = 4,
                        init = "0",
                        cores = 4,
                        seed = 389253)
    
    cur_draws = as_draws_df(cur_m)
    cur_draws$subnum = cur_sub
    
    yn_attr_cor_draws = rbind(yn_attr_cor_draws, cur_draws)
  }
  names(yn_attr_cor_draws) = gsub(":", ".", names(yn_attr_cor_draws))
  write.csv(yn_attr_cor_draws, fn_draws, row.names = F)

  rm(cur_dat, cur_m, cur_draws, cur_sub)
}
rm(subnums)
```

```{r}
names(as_tibble(yn_attr_cor_draws))[grepl("b_", names(as_tibble(yn_attr_cor_draws)))]
```
```{r}
yn_par_summary = as.tibble(yn_attr_cor_draws) %>%
  select(subnum, b_Intercept, b_valueO, b_valueF, b_valueS, b_type1, b_valueO.valueF, b_valueO.valueS, b_valueF.valueS, b_valueO.type1, b_valueF.type1, b_valueS.type1, b_valueO.valueF.valueS, b_valueO.valueF.type1, b_valueO.valueS.type1, b_valueF.valueS.type1, b_valueO.valueF.valueS.type1) %>%
  gather(key, value, -subnum) %>%
  mutate(key = recode(key,
                      "b_Intercept" = "Intercept",
                      "b_valueO" = "Orientation Value [-1, 1]", 
                      "b_valueF" = "Filling Value [-1, 1]", 
                      "b_valueS" = "Shape Value [-1, 1]", 
                      "b_type1" = "Type (HT = 1, RE = 0)",
                      "b_valueO.type1" = "Value O x Type",
                      "b_valueF.type1" = "Value F x Type",
                      "b_valueS.type1" = "Value S x Type",
                      "b_valueO.valueF" = "Value O x F", 
                      "b_valueO.valueS" = "Value O x S", 
                      "b_valueF.valueS" = "Value F x S", 
                      "b_valueO.valueF.type1" = "Value O x F x Type", 
                      "b_valueO.valueS.type1" = "Value O x S x Type", 
                      "b_valueF.valueS.type1" = "Value F x S x Type",
                      "b_valueO.valueF.valueS" = "Value O x F x S",
                      "b_valueO.valueF.valueS.type1" = "Value O x F x S x Type"),
         key = factor(key, levels = c("Intercept", "Orientation Value [-1, 1]", "Filling Value [-1, 1]", "Shape Value [-1, 1]", "Type (HT = 1, RE = 0)", "Value O x Type", "Value F x Type", "Value S x Type", "Value O x F", "Value O x S", "Value F x S", "Value O x F x Type", "Value O x S x Type", "Value F x S x Type", "Value O x F x S", "Value O x F x S x Type"))) %>%
  group_by(subnum, key) %>%
  summarise(.groups = 'keep',
            m = mean(value),
            l95 = HDInterval::hdi(value)[1],
            h95 = HDInterval::hdi(value)[2]) %>%
  mutate(subnum = as.factor(subnum))
```

```{r}
p = yn_par_summary %>%
  ggplot(aes(m, subnum)) +
  geom_vline(aes(xintercept = 0), color = "gray") + 
  geom_point(position = position_dodge(width=.75))+
  geom_errorbarh(aes(xmin = l95, xmax = h95, height=.2), position = position_dodge(width=.75))+
  facet_wrap(~key, scales = 'free_x', nrow = 2) +
  labs(x = "Parameter Estimate", y = "Subject", color = "", title = "95% HDI for posterior slopes - Correct ~ Orientation x Filling x Shape x Type") +
  theme(legend.position = "bottom",
        panel.grid = element_blank(),
        legend.box.margin=margin(t = -10))+
  scale_x_symmetric(mid=0)

# ggsave(file=paste0(fig_out_path, 'yn_attrEffectsByStimType_ParEsts.jpg'), p, height = 5, width = 12, units="in")

p

```
## Reference amount effect on accuracy

### Treating reference continously

Though discrete might be more appropriate

```{r}
names(data_yn_clean)

summary(data_yn_clean$reference)
```

```{r}
fn_draws = paste0(inputs_path, 'yn_refValAcc_draws.csv')

if(file.exists(fn_draws)){
  yn_refval_draws = read.csv(fn_draws)
} else{
  subnums = unique(data_yn_clean$subnum)
 
  yn_refval_draws = tibble()
  
  normMax = 1
  normMin = 0
  normMinRef = -1
  
  for(cur_sub in subnums){
  
    cur_dat = data_yn_clean %>% 
      ungroup() %>%
      filter(subnum == cur_sub) %>%
      mutate(type = as.factor(type),
             norm_day = (normMax - normMin) / (max(day) - min(day)) * (day - max(day)) + (normMax),
             norm_reference = (normMax - normMinRef) / (max(reference) - min(reference)) * (reference - max(reference)) + (normMax))
    
    cur_m <- brm(formula = correct ~  norm_reference * norm_day * type,
                        data= cur_dat,
                        family = bernoulli(link = "logit"),
                        warmup = 500,
                        iter = 2500,
                        chains = 4,
                        init = "0",
                        cores = 4,
                        seed = 389253)
    
    cur_draws = as_draws_df(cur_m)
    cur_draws$subnum = cur_sub
    
    yn_refval_draws = rbind(yn_refval_draws, cur_draws)
  }
  names(yn_refval_draws) = gsub(":", ".", names(yn_refval_draws))
  write.csv(yn_refval_draws, fn_draws, row.names = F)

  rm(cur_dat, cur_m, cur_draws, cur_sub)
}
rm(subnums)
```


```{r}
names(as_tibble(yn_refval_draws))[grepl("b_", names(as_tibble(yn_refval_draws)))]
```

```{r}
yn_par_summary = as.tibble(yn_refval_draws) %>%
  select(subnum, b_Intercept, b_norm_reference, b_norm_day, b_type1, b_norm_reference.norm_day, b_norm_reference.type1, b_norm_day.type1, b_norm_reference.norm_day.type1) %>%
  gather(key, value, -subnum) %>%
  mutate(key = recode(key,
                      "b_Intercept" = "Intercept",
                     "b_norm_reference" = "Reference [-1, 1]",
                     "b_norm_day" = "Day [0, 1]",
                     "b_type1" = "Type (HT = 1, RE = 0)",
                     "b_norm_reference.norm_day" = "Reference x Day",
                     "b_norm_reference.type1" = "Reference x Type",
                     "b_norm_day.type1" = "Day x Type",
                     "b_norm_reference.norm_day.type1" = "Reference x Day x Type"),
         key = factor(key, levels = c("Intercept", "Reference [-1, 1]", "Day [0, 1]", "Type (HT = 1, RE = 0)","Reference x Day", "Reference x Type","Day x Type","Reference x Day x Type"))) %>%
  group_by(subnum, key) %>%
  summarise(.groups = 'keep',
            m = mean(value),
            l95 = HDInterval::hdi(value)[1],
            h95 = HDInterval::hdi(value)[2]) %>%
  mutate(subnum = as.factor(subnum))
```

```{r}
p = yn_par_summary %>%
  ggplot(aes(m, subnum)) +
  geom_vline(aes(xintercept = 0), color = "gray") + 
  geom_point(position = position_dodge(width=.75))+
  geom_errorbarh(aes(xmin = l95, xmax = h95, height=.2), position = position_dodge(width=.75))+
  facet_wrap(~key, scales = 'free_x', nrow = 2) +
  labs(x = "Parameter Estimate", y = "Subject", color = "", title = "95% HDI for posterior slopes - Correct ~ Reference x Day x Type") +
  theme(legend.position = "bottom",
        panel.grid = element_blank(),
        legend.box.margin=margin(t = -10))+
  scale_x_symmetric(mid=0)

# ggsave(file=paste0(fig_out_path, 'yn_attrEffectsByStimType_ParEsts.jpg'), p, height = 5, width = 12, units="in")

p

```

```{r}
fn_draws = paste0(inputs_path, 'yn_refDiscValAcc_draws.csv')

if(file.exists(fn_draws)){
  yn_refval_draws = read.csv(fn_draws)
} else{
  subnums = unique(data_yn_clean$subnum)
 
  yn_refval_draws = tibble()
  
  normMax = 1
  normMin = 0
  normMinRef = -1
  
  for(cur_sub in subnums){
  
    cur_dat = data_yn_clean %>% 
      ungroup() %>%
      filter(subnum == cur_sub) %>%
      mutate(type = as.factor(type),
             norm_day = (normMax - normMin) / (max(day) - min(day)) * (day - max(day)) + (normMax),
             disc_reference = factor(reference, levels = c(0, -50, 50)))
    
    cur_m <- brm(formula = correct ~  disc_reference * norm_day * type,
                        data= cur_dat,
                        family = bernoulli(link = "logit"),
                        warmup = 500,
                        iter = 2500,
                        chains = 4,
                        init = "0",
                        cores = 4,
                        seed = 389253)
    
    cur_draws = as_draws_df(cur_m)
    cur_draws$subnum = cur_sub
    
    yn_refval_draws = rbind(yn_refval_draws, cur_draws)
  }
  names(yn_refval_draws) = gsub(":", ".", names(yn_refval_draws))
  write.csv(yn_refval_draws, fn_draws, row.names = F)

  rm(cur_dat, cur_m, cur_draws, cur_sub)
}
rm(subnums)
```

```{r}
names(as_tibble(yn_refval_draws))[grepl("b_", names(as_tibble(yn_refval_draws)))]
```

```{r}
yn_par_summary = as.tibble(yn_refval_draws) %>%
  select(subnum, b_Intercept, b_disc_referenceM50, b_disc_reference50, b_norm_day, b_type1, b_disc_referenceM50.norm_day, b_disc_reference50.norm_day, b_disc_referenceM50.type1, b_disc_reference50.type1, b_norm_day.type1, b_disc_referenceM50.norm_day.type1,b_disc_reference50.norm_day.type1 ) %>%
  gather(key, value, -subnum) %>%
  mutate(key = recode(key,
                      "b_Intercept" = "Intercept",
                     "b_disc_referenceM50" = "Reference 0 vs -50",
                     "b_disc_reference50" = "Reference 0 vs 50",
                     "b_norm_day"= "Day [0, 1]",
                     "b_type1" = "Type (HT = 1, RE = 0)",
                     "b_disc_referenceM50.norm_day" = "Reference 0 vs -50 x Day",
                     "b_disc_reference50.norm_day" = "Reference 0 vs 50 x Day",
                     "b_disc_referenceM50.type1" = "Reference 0 vs -50 x Type",
                     "b_disc_reference50.type1" = "Reference 0 vs 50 x Type",
                     "b_norm_day.type1"  = "Day x Type",
                     "b_disc_referenceM50.norm_day.type1" = "Reference 0 vs -50 x Day x Type",
                     "b_disc_reference50.norm_day.type1" = "Reference 0 vs 50 x Day x Type"),
         key = factor(key, levels = c("Intercept", "Reference 0 vs -50", "Reference 0 vs 50", "Day [0, 1]", "Type (HT = 1, RE = 0)", "Reference 0 vs -50 x Day", "Reference 0 vs 50 x Day", "Reference 0 vs -50 x Type", "Reference 0 vs 50 x Type", "Day x Type", "Reference 0 vs -50 x Day x Type", "Reference 0 vs 50 x Day x Type"))) %>%
  group_by(subnum, key) %>%
  summarise(.groups = 'keep',
            m = mean(value),
            l95 = HDInterval::hdi(value)[1],
            h95 = HDInterval::hdi(value)[2]) %>%
  mutate(subnum = as.factor(subnum))
```

```{r}
p = yn_par_summary %>%
  ggplot(aes(m, subnum)) +
  geom_vline(aes(xintercept = 0), color = "gray") + 
  geom_point(position = position_dodge(width=.75))+
  geom_errorbarh(aes(xmin = l95, xmax = h95, height=.2), position = position_dodge(width=.75))+
  facet_wrap(~key, scales = 'free_x', nrow = 2) +
  labs(x = "Parameter Estimate", y = "Subject", color = "", title = "95% HDI for posterior slopes - Correct ~ Reference x Day x Type") +
  theme(legend.position = "bottom",
        panel.grid = element_blank(),
        legend.box.margin=margin(t = -10))+
  scale_x_symmetric(mid=0)

# ggsave(file=paste0(fig_out_path, 'yn_attrEffectsByStimType_ParEsts.jpg'), p, height = 5, width = 12, units="in")

p

```

# Coding closeness to HT

```{r}
data_yn_clean %>%
  filter(subnum == 601 & type == 1) %>%
  select(type, stimNum, shape, filling, orientation) %>%
  distinct() %>%
  arrange(stimNum)

sort(unique(data_yn_clean$filling))

sort(unique(data_yn_clean$orientation))

# For each of the HT stims define CHT stims as:
  # same filling, same orientation, different shape (5 stims)
  # same shape, same orientation. filling level +/- 1 (2 stims)
  # same shape, filling, orientation level +/1 (2 stims)

get_cht_stims = function(shape_level, filling_level, orientation_level){
  filling_levels = sort(unique(data_yn_clean$filling))
  
  orientation_levels = sort(unique(data_yn_clean$orientation))
  
  shape_levels = sort(unique(data_yn_clean$shape))
  
  close_shape_levels = shape_levels[shape_levels != shape_level]

  orientation_level_index = which(orientation_levels == orientation_level)  
  
  if(orientation_level_index == 1){
    close_orientation_level = orientation_levels[2]
  } else if (orientation_level_index == length(orientation_levels)){
    close_orientation_level = orientation_levels[length(orientation_levels) - 1]
  } else{
    close_orientation_level = orientation_levels[c(orientation_level_index-1, orientation_level_index+1)]
  }
  
}
```
