---
title: "Novel vs. repeated choice project: DDM with collapsing bounds"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: 'hide'
---

Set up environment and load in data

```{r include=FALSE, message=FALSE}
library(tidyverse)
library(here)
library(grid)
library(gridExtra)
theme_set(theme_bw())
helpers_path = paste0(here(),'/analysis/helpers/')
source(paste0(helpers_path, '01_clean_behavioral_data.R'))
rm(data_bc_clean)
fig_out_path = paste0(here(), '/outputs/fig/')
```

**Make sure to demean value and exclude too fast trials before fitting**

```{r}
data_yn_clean = data_yn_clean %>%
  # filter(reference != -99) %>% 
  # filter(rt > .3 & rt < 5) %>% # discard very long and short RT trials
  group_by(subnum, day, type) %>%
  mutate(possiblePayoff_dmn = possiblePayoff - mean(possiblePayoff)) 
```

# Exploring priors and parameter space

What does a subject prior for drift rates look like in the HDDM

```
d.mu ~ dunif(.00001, 50)
d.pr ~ dgamma(1, .1)
d[subject] ~ dnorm(d.mu, d.pr) [trimmed at 10e-5, 50]

```

```{r}
n = 10000

dat = data.frame(d.mu = runif(n, .00001, 50), d.pr = rgamma(n, 1, .1))

for(i in 1:nrow(dat)){
  dat$d[i] = rnorm(1, dat$d.mu[i], dat$d.pr[i])
}

dat$d = ifelse(dat$d > 50, 50, ifelse(dat$d<.000001, .000001, dat$d))

dat %>%
  # select(d) %>%
  gather(key, value) %>%
  # mutate(key = factor(key, levels = c("d.pr", "d.mu", "d"))) %>%
  ggplot(aes(value, fill=key))+
  geom_histogram(position = "identity", alpha = .5, bins = 30)+
  facet_wrap(~key, scales = "free")+
  theme(legend.position = "bottom")+
  labs(fill="", x="")
```

If these are the priors you use what is the prior probability of any given d from a uniform prior?

(So you can use it to multiply with the likelihood to get an unnormalized posterior?)

If it's a uniform prior then it doesn't really matter since the prior will be the same for all values.

In the HDDMs d and sigma have uniform priors (yay!)

What about the bias and ndt? Uniform-ish too.

```
bias[p] ~ dbeta(bias.alpha, bias.beta)T(0.01,0.99)

bias.alpha <- bias.mu * bias.kappa
bias.beta <- (1 - bias.mu) * bias.kappa
bias.mu ~ dbeta(2, 2)T(0.01,0.99)
bias.kappa ~ dgamma(1, 0.5)
```

**NOTE: This is operationalized in the HDDM, ranging from 0 to 1 and no bias is .5**

```{r}
n = 10000

dat = data.frame(bias.kappa = rgamma(n, 1, .5), bias.mu = rbeta(n, 2, 2))

dat$bias.mu = ifelse(dat$bias.mu < .01, .01, ifelse(dat$bias.mu > .99, .99, dat$bias.mu))

dat = dat %>%
  mutate(bias.beta = (1 - bias.mu) * bias.kappa,
         bias.alpha = bias.mu * bias.kappa)

for(i in 1:nrow(dat)){
  dat$bias[i] = rbeta(1, dat$bias.alpha[i], dat$bias.beta[i])
}

dat$bias = ifelse(dat$bias < .01, .01, ifelse(dat$bias > .99, .99, dat$bias))

dat %>%
  gather(key, value) %>%
  ggplot(aes(value, fill=key))+
  geom_histogram(position = "identity", alpha = .5, bins = 30)+
  facet_wrap(~key, scales = "free")+
  theme(legend.position = "bottom")+
  labs(fill="", x="")

```

```
theta.p[p] ~ dnorm(ndt.mu, ndt.pr)T(0.01, 1)
ndt.pr ~ dgamma(1, 0.1)
ndt.mu ~ dunif(0, 1)
```

```{r}
n = 10000

dat = data.frame(ndt.mu = runif(n, 0, 1), ndt.pr = rgamma(n, 1, .1))

for(i in 1:nrow(dat)){
  dat$ndt[i] = rnorm(1, dat$ndt.mu[i], dat$ndt.pr[i])
}

dat$ndt = ifelse(dat$ndt < .01, .01, ifelse(dat$ndt > 1, 1, dat$ndt))

dat %>%
  gather(key, value) %>%
  ggplot(aes(value, fill=key))+
  geom_histogram(position = "identity", alpha = .5, bins = 30)+
  facet_wrap(~key, scales = "free")+
  theme(legend.position = "bottom")+
  labs(fill="", x="")

```

Ok, so if we assume uniform (uninformative) priors for every parameter (d, sigma, bias, ndt, barrierDecay) then the posteriors will be proportional to the likelihood. 

What are reasonable values for barrierDecay? Prior: Uniform[0, .01]; min = 0, max = 0.02

```{r}
decay_vals = c(0, .001, .01, .02, .1, 1)

dat = data.frame()

for(cur_dv in decay_vals){
  cur_dat = data.frame(t = c(0:maxIter),
                       initialBarrier = 1, 
                       barrierDecay = cur_dv)
  
  cur_dat = cur_dat %>%
    mutate(barrier = initialBarrier / (1 + (barrierDecay * t)))
  
  dat = rbind(dat, cur_dat)
}

dat %>%
  mutate(barrierDecay = factor(barrierDecay, levels = decay_vals)) %>%
  ggplot(aes(t, barrier, color = barrierDecay))+
  geom_point()+
  theme_bw()+
  theme(legend.position = "bottom")
```

# Test trial simulation function

Simulate a few trials

```{r}
source(paste0(helpers_path, '/ddm/yn_ddm.R'))
```

```{r}
cur_d = .03
cur_sigma = .02
cur_nonDecisionTime = 300 #ms
cur_bias = 0
cur_barrierDecay = .002

cur_valStim = .25
cur_valRef = 0

# cur_valStim = data_yn_clean$possiblePayoff_dmn[100]
# cur_valRef = data_yn_clean$reference[100] #mean is 0 so not mutated

tmp = sim_trial(d = cur_d, sigma = cur_sigma, nonDecisionTime = cur_nonDecisionTime, bias = cur_bias, barrierDecay = cur_barrierDecay, ValStim = cur_valStim, ValRef = cur_valRef, debug = T)

tmp
```

```{r}
tmp$debug_df %>%
  mutate(RDV = ifelse(time<31, NA, RDV)) %>%
  ggplot()+
  geom_line(aes(time, RDV), color = "#F8766D", size = 2)+
  geom_line(aes(time, barrier))+
  geom_line(aes(time, -barrier))+
  theme(panel.grid = element_blank())+
  geom_hline(aes(yintercept = 0), linetype = "dashed")+
  geom_hline(aes(yintercept = 1), linetype = "dashed")+
  geom_hline(aes(yintercept = -1), linetype = "dashed")+
  geom_vline(aes(xintercept = 30), color = "gray")+
  labs(x = "Timestep (in 10 ms)")
```

# Test task simulation function

```{r}
source(paste0(helpers_path, '/ddm/sim_yn_ddm.R'))
```

```{r}
cur_d = .003
cur_sigma = .002
cur_nonDecisionTime = 300 #ms
cur_bias = 0
cur_barrierDecay = .002

sub_stims = data_yn_clean %>%
  filter((subnum == 611) & (day == 4) & (type == 1))

# names(sub_stims)

sim_trial_list = list("model1" = sim_trial)

tmp = sim_task(stimuli = sub_stims, model_name = "model1", sim_trial_list_ = sim_trial_list, d = cur_d, sigma = cur_sigma, nonDecisionTime = cur_nonDecisionTime, bias = cur_bias, barrierDecay = cur_barrierDecay, debug = T)

tmp %>%
  mutate(absValDiff = abs(ValStim - ValRef)) %>%
  arrange(absValDiff)


```

# Test trial likelihood function

```{r}
source(paste0(helpers_path, '/ddm/yn_ddm.R'))
```

```{r}
i = 1

tmp[i,]
```

```{r}
fit_trial(d = cur_d, sigma = cur_sigma, nonDecisionTime = cur_nonDecisionTime, bias = cur_bias, barrierDecay = cur_barrierDecay, choice = tmp$choice[i], reactionTime = tmp$reactionTime[i], ValStim = tmp$ValStim[i], ValRef = tmp$ValRef[i])
```

```{r}
fit_trial(d = cur_d*10, sigma = cur_sigma*10, nonDecisionTime = cur_nonDecisionTime, bias = cur_bias, barrierDecay = cur_barrierDecay, choice = tmp$choice[i], reactionTime = tmp$reactionTime[i], ValStim = tmp$ValStim[i], ValRef = tmp$ValRef[i])
```

```{r}
fit_trial(d = cur_d/2, sigma = cur_sigma, nonDecisionTime = cur_nonDecisionTime, bias = cur_bias, barrierDecay = cur_barrierDecay, choice = tmp$choice[i], reactionTime = tmp$reactionTime[i], ValStim = tmp$ValStim[i], ValRef = tmp$ValRef[i])
```

# Test task fitting functions

```{r}
source(paste0(helpers_path, '/ddm/fit_yn_ddm.R'))
```

```{r}
cur_d = .003
cur_sigma = .002
cur_nonDecisionTime = 300 #ms
cur_bias = 0
cur_barrierDecay = .002

fit_trial_list = list("model1" = fit_trial)

fit_task(data_ = tmp[1:100,], model_name_ = "model1", pars_ = list(d = cur_d, sigma = cur_sigma, nonDecisionTime = cur_nonDecisionTime, bias = cur_bias, barrierDecay = cur_barrierDecay) , fit_trial_list_ = fit_trial_list, debug=FALSE)
```

Is negative log likelihood lower for the true parameter combination compared to other combinations?

```{r}
get_task_nll(data_ = tmp[1:100,], par_ = c(cur_d, cur_sigma, cur_nonDecisionTime, cur_bias, cur_barrierDecay), par_names_ = c("d", "sigma", "nonDecisionTime", "bias", "barrierDecay"), model_name_ = "model1")
```

```{r}
get_task_nll(data_ = tmp[1:100,], par_ = c(cur_d/2, cur_sigma, cur_nonDecisionTime, cur_bias, cur_barrierDecay), par_names_ = c("d", "sigma", "nonDecisionTime", "bias", "barrierDecay"), model_name_ = "model1")
```

```{r}
get_task_nll(data_ = tmp[1:100,], par_ = c(cur_d, cur_sigma/2, cur_nonDecisionTime, cur_bias, cur_barrierDecay), par_names_ = c("d", "sigma", "nonDecisionTime", "bias", "barrierDecay"), model_name_ = "model1")
```

# Test optim

```{r eval = FALSE}

max_iter = 100

par_names = c("d", "sigma", "nonDecisionTime", "bias", "barrierDecay")

subnums = sort(unique(data_yn_clean$subnum))
subnums = subnums[1]
days = sort(unique(data_yn_clean$day))
days = days[1]
types = sort(unique(data_yn_clean$type))

for(cur_sub in subnums){
  for(cur_day in days){
    for(cur_type in types){
      
      cur_dat = data_yn_clean %>%
        filter((subnum == cur_sub) & (day == cur_day) & (type == cur_type)) %>%
        filter(reference != -99) %>%
        filter(rt > .3 & rt < 5)
      
      start_num = 1
      while(start_num < 100){
        # while(start_num < 10){
        start_d = runif(1, .00001, 1)
        start_sigma = runif(1, 0.000001, 2)
        start_nonDecisionTime = runif(1, 10, 500)
        start_bias = runif(1, -1, 1)
        start_barrierDecay = runif(1, 0, .01)
        
        start_vals = c(start_d, start_sigma, start_nonDecisionTime, start_bias, start_barrierDecay)
        
        optim_out = optim(par = start_vals, get_task_nll, data_= cur_dat, par_names_ = par_names, model_name_ = "model1", control = list(maxit=max_iter))
        
        cur_out = data_frame(key = par_names, value = optim_out$par)
        cur_out = cur_out %>% spread(key, value)
        cur_out$nll = optim_out$value
        cur_out$optim_iters = as.numeric(optim_out$counts[1])
        cur_out$subnum = cur_sub
        cur_out$day = cur_day
        cur_out$type = cur_type
        cur_out = cbind(cur_out, data_frame(key = paste0("start_", par_names), value = start_vals) %>% spread(key, value))
        cur_out$start_num = start_num
        
        if(start_num == 1){
          out = cur_out
        } else{
          out = rbind(out, cur_out)
        }
        
        start_num = start_num + 1 
      }
      
      fn_type = ifelse(cur_type == 1, "HT", "RE")
      fn = paste0("optim_YN_DDM_FIT_sub-",cur_sub, "_",fn_type,"_day_",cur_day,".csv")
      write.csv(out, paste0(here(), '/inputs/',fn), row.names = F)
    }
  }
}

out
```

```{r}
get_task_nll(data_ = tmp, par_ = c(cur_d, cur_sigma, cur_nonDecisionTime, cur_bias, cur_barrierDecay), par_names_ = c("d", "sigma", "nonDecisionTime", "bias", "barrierDecay"), model_name_ = "model1")
```

## Single subject estimates

Read in the estimates for a single subject:

```{r}
cur_sub = 601

all_files = list.files(path = paste0(here(), '/inputs/'), pattern= paste0("optim_YN_DDM_FIT_sub-",cur_sub))

optim_out= data.frame()

for (cur_file in all_files){
  cur_in = read.csv(paste0(here(), '/inputs/', cur_file))
  optim_out = rbind(optim_out, cur_in)
}

optim_out
```

Distribution of estimates

```{r}
optim_out %>%
  select(d, sigma, nonDecisionTime, bias, barrierDecay) %>%
  gather(key, value) %>%
  ggplot(aes(value, fill = key))+
  geom_histogram(bins = 30, alpha = .5)+
  facet_wrap(~key, scales = "free")+
  theme(legend.position = "none",
        panel.grid = element_blank())
```

```{r}
p = optim_out %>%
  select(d, sigma, nonDecisionTime, bias, barrierDecay, day, type) %>%
  gather(key, value, -day, -type) %>%
  group_by(key, day, type) %>%
  summarise(mean_par = mean(value), 
            sem_par = sd(value)/sqrt(n()), .groups = "keep") %>%
  mutate(type = ifelse(type == 1, "HT", "RE"),
         key = factor(key, levels = c("d", "sigma", "nonDecisionTime", "bias", "barrierDecay"))) %>%
  ggplot(aes(day, mean_par, color = type))+
  geom_point(position = position_dodge(width=.5))+
  geom_errorbar(aes(ymin = mean_par - sem_par, ymax = mean_par + sem_par), width = .1, position = position_dodge(width=.5)) +
  facet_wrap(~key, scales = "free", ncol = 5) +
  theme(legend.position = "bottom",
        panel.grid.minor = element_blank())+
  scale_color_brewer(palette = "Dark2")+
  labs(y = "", color = "")+
  scale_x_continuous(breaks = seq(1:11))

ggsave(file=paste0(fig_out_path, 'yn_sub-',cur_sub,'_optimDDMparsOverDays.jpg'), p, height = 4, width=12, units="in")

```

Correlation between estimates

```{r}
# Average correlation across days of HT

cor_mats = list()
for(cur_day in c(1:11)){
  cor_dt = optim_out %>%
    filter((type == 1) & (day == cur_day)) %>%
    select(d, sigma, nonDecisionTime, bias, barrierDecay)
  
  cor_mats[[cur_day]] = cor(cor_dt)
  
  
}

mean_cor_mat = Reduce("+", cor_mats) / length(cor_mats)
tg = tableGrob(round(mean_cor_mat, 3) )
ggsave(paste0(fig_out_path, "sub-",cur_sub, "_ddmOptimHTparCors.jpg"), tg, width = 12, height = 4)
```

```{r}
# Average correlation across days of HT

cor_mats = list()
for(cur_day in c(1:11)){
  cor_dt = optim_out %>%
    filter((type == 0) & (day == cur_day)) %>%
    select(d, sigma, nonDecisionTime, bias, barrierDecay)
  
  cor_mats[[cur_day]] = cor(cor_dt)
  
  
}

mean_cor_mat = Reduce("+", cor_mats) / length(cor_mats)
tg = tableGrob(round(mean_cor_mat, 3) )
ggsave(paste0(fig_out_path, "sub-",cur_sub, "_ddmOptimREparCors.jpg"), tg, width = 12, height = 4)
```

Correlation between each parameter and its starting point

```{r}
optim_out %>%
  ggplot(aes(start_d, d))+
  geom_point(size = 1)

optim_out %>%
  ggplot(aes(start_sigma, sigma))+
  geom_point(size = 1)

optim_out %>%
  ggplot(aes(start_nonDecisionTime, nonDecisionTime))+
  geom_point(size = 1)

optim_out %>%
  ggplot(aes(start_bias, bias))+
  geom_point(size = 1)

optim_out %>%
  ggplot(aes(start_barrierDecay, barrierDecay))+
  geom_point(size = 1)
```

```{r}
optim_out %>%
  select(d, start_d)

optim_out %>%
  select(sigma, start_sigma)

optim_out %>%
  select(nonDecisionTime, start_nonDecisionTime)

optim_out %>%
  select(bias, start_bias)

optim_out %>%
  select(barrierDecay, start_barrierDecay)
```

```{r}
optim_out %>%
  mutate(diff_d = abs(d - start_d),
         diff_sigma = abs(sigma - start_sigma),
         diff_bias = abs(bias - start_bias),
         diff_nonDecisionTime = abs(nonDecisionTime - start_nonDecisionTime),
         diff_barrierDecay = abs(barrierDecay - start_barrierDecay)) %>%
  select(diff_d, diff_sigma, diff_bias, diff_nonDecisionTime, diff_barrierDecay) %>%
  gather(key, value) %>%
  select(value) %>%
  distinct()
```

Posterior predictive data

```{r}
source(paste0(helpers_path, '/ddm/yn_ddm.R'))
```

Checks of stylized behavioral effects

```{r}

```
